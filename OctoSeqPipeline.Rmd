---
title: "OctoSeqPipeline"
author: "jos"
date: "4/1/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.

## Inserting chunks of code

To insert a chunk of code, use Cmd + Option + I

### Begin Code
Protocol for analyzing Octo Seq data using RStudio (3.6.3), Seurat (3.1.4), Mac (OS Catalina 10.15.3)

## Download Seurat packages (source: https://satijalab.org/seurat/install.html) ~
# Enter commands in R or RStudio
```{r}
install.packages('BiocManager')
BiocManager::install('multtest') 
# Do you want to install from sources the packages which need compilation? (y/n/cancel) Yes
install.packages('Seurat')
# package which is only available in source form, and may need compilation? (y/n) Yes
library(Seurat)
# Would you like to install Miniconda? (y/n) Y
```
## Download FUSE for macOS to be able to mount to Talapas using sshfs
Go to this website: https://osxfuse.github.io
Follow instructions and allow Benjamin Fisher access through System Preferences
Install Brew packagemanager (source: https://brew.sh): in terminal command, enter: /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)" 
In terminal command, enter: brew install sshfs 

# Mount to talapas
In terminal command, enter: sshfs jsongco@talapas-ln1.uoregon.edu:/projects/niell/jsongco /Users/josongco/Talapas 
Prior to mounting, user will need to create a directory to mount to; in my case, I created the directory "Talapas"

## Set working directory 
```{r}
setwd("/Users/josongco/Desktop/SeqData")
```

## Load libraries for Seurat
```{r}
library(Seurat) # load if not already loaded from installation
library(Matrix)
library(ggplot2)
library(sctransform)
library(stringr)
```

## Creating data frames and setting parameters for data analysis
```{r}
# create a data frame to hold the directories
datafiles <- data.frame("Run" = 1:6, "Directory" = c("/Users/josongco/Talapas/Cellranger/OctoSeq1/raw_feature_bc_matrix", "/Users/josongco/Talapas/Cellranger/OctoSeq2.1/raw_feature_bc_matrix", "/Users/josongco/Talapas/Cellranger/OctoSeq2.2/raw_feature_bc_matrix", "/Users/josongco/Talapas/Cellranger/HiSat1/raw_feature_bc_matrix", "/Users/josongco/Talapas/Cellranger/HiSat2.1/raw_feature_bc_matrix", "/Users/josongco/Talapas/Cellranger/HiSat2.2/raw_feature_bc_matrix"))
# if 1:3, old Octo Seq data; if 4:6, new Octo Seq data with updated gtf file
str(datafiles) # view the structure of the data frame

# Parameters: 
x = 1 # if x is set to 1, data will be from runs 1:3 using old gtf file with ocbim; otherwise, data will be from runs 4:6 (see above) using new gtf file with OCTOgene
sct = 0 # if sct = 0, data will be taken through standard pre-processing steps; otherwise, data will be taken through scTransform for data pre-processing
t = 1; # if t is set to 1, you will be finding cluster markers based on the hierarchical tree; otherwise, cluster markers will be generated based on original UMAP
```

## Using a for loop, load in Octo Seq Data and take data through pre-processing steps
```{r}
if(x = 1){
  for (f in 1:3){
    data_dir <- datafiles$dir
    list.files(data_dir)
    all <- Read10X(data.dir = data_dir[f])
    
    ref <- read.csv("/Users/josongco/Desktop/SeqData/miniNCBI_annotations_alltomitochondria_022420.csv", stringsAsFactors = FALSE)
      ngenes <- length(all@Dimnames[[1]])
      for (g in 1:ngenes){
        gene <- all@Dimnames[[1]][g]
        gene <- substr(gene, 6, str_length(gene)-2)
        ind<- grep(gene, ref[[1]])
        if (length(ind)>0) {
          id <- str_remove_all(id, "\\(") # parentheses mess up gene names as dimensions
          id <- str_remove_all(id, "\\)") 
          id <- substr(id, 1, 60) # keep it short
          all@Dimnames[[1]][g] <- pase(id, gene, sep= '-')
        }
      }
  }
  
all <- CreateSeuratObject(counts = all, project = "OctoSeq[f]", min.cells = 3, min.features = 200)
all

#all[["percent.mt"]] <- PercentageFeatureSet(all, pattern = "^mitochondria-") # Seurat uses this function to extract information re: mitochondrial genes

mito.genes <- grep(pattern = "^mitochondria-", x = rpwnames(x = all), value = TRUE)
percent.mito <- Matrix::colSums(all) / Matrix::colSums(all)
all[["percent.mt"]] <- PercentageFeatureSet(all, pattern = "^mitochondria-")

VlnPlot(all, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3) # visualize the relationship between three variables: nFeature (genes) nCount (UMI counts) and percent.mt (mitochondrial genes)

plot1 <- FeatureScatter(all, feature1 = "nCount_RNA", feature2 = "percent.mt") # visualize the relationship between UMI counts and mitochondrial genes (percent)
plot2 <- FeatureScatter(all, feature1 = "nCount_RNA", feature2 = "nFeature_RNA") # visualize the relationship between genes (ID as > 1 UMI count) and mitochondrial genes (percent)
plot1 + plot2

all <- subset(all, subset = nFeature_RNA > 200 & nFeature_RNA < 2500 & percent.mt < 5) # set parameters to include cells with the following critera: > 200, < 2500, less than 5% mitochondrial genes, since a higher number of mitochondrial genes is indicative of stress 

## Begin normalizing the data: Apply global scaling after removing unwanted cells from the dataset

if(sct = 0){

all <- NormalizeData(all) # applies a Log Normalize by scale factor of 10,000 as default

## ID highly variable features (feature selection) 
# To calculate a subset of features that exhibit high cell-to-cell variation in the dataset (i.e. genes that are highly expressed in some cells and lowly expressed in others), the following function returns 2,000 features per data set, which will be used in downstream analyses like PCA
all <- FindVariableFeatures(all, selection.method = "vst", nfeatures = 2000)
top10 <- head(VariableFeatures(all), 10) # ID 10 most highly variable genes
plot1 <- VariableFeaturePlot(all)
plot2 <- LabelPoints(plot = plot1, points = top10, repel = TRUE)
plot1 + plot2

## Scale the data: this is a standard pre-processing step required for dimensional reduction techniques
# Applies a linear transformation: 1) shifts the expression of each gene so that the mean expression across cells is 0, 2) scales the expression of each gene so that the variance across cells is 1, allowing for downstream analyses to utilize equal weight of each gene so that highly-expressed genes do not dominate; 3) results will be stored in all[["RNA]]@scale.data
all.genes <- rownames(all)
all <- ScaleData(all, vars.to.regress = "nCount_RNA", "percent.mt") # regress out UMI counts and percent.mt which is helpful when integrating v2 and v3 chemistry; alt: all <- ScaleData(all, features = all.genes)

} else {
  all <- SCTransform(all, vars.to.regress = c("nCount_RNA", "percent.mt"))
}

} else {
  for (f in 4:6){
    data_dir <- datafiles$dir
    list.files(data_dir)
    all <- Read10X(data.dir = data_dir[f])
    
    # Read in name key which has OCTOGene and ocbim names
    ref <- read.csv("cov4_len200_splice3_strandness_gtf_namekey_singled_edited.csv", stringsAsFactors = FALSE)
    ngenes <- length(octo.data@Dimnames[[1]])
    
    # Combine Hisat names with Ocbim names *Note: this step can take some time, but only has to be run once if you save
    for (g in 1:ngenes){
      gene <- octo.data@Dimnames[[1]][g]
      ind <- grep(gene, ref[[1]])
      unlist(ind)
      if (length(ind)>0){
        id <- ref[[ind[1], 2]]
        if (str_length(id)>0){
          octo.data@Dimnames[[1]][g]  <- paste(id,gene,sep = '-')
        }
        
      }
    }
    
    # Replace underscores with dashes within names
    for (g in 1:ngenes){
      gene <- octo.data@Dimnames[[1]][g]
      new <- str_replace_all(gene, "_", "-")
      octo.data@Dimnames[[1]][g] <- paste(new)
    }
    
    # Save here
    saveRDS(octo.data, file = "/Users/josongco/Desktop/SeqData/octoData_onlyHisatNames.rds")
    
    # Read in "real" gene names
    ref <- read.csv("miniNCBI_annotations_alltomitochondrial.csv", stringsAsFactors = FALSE)
    ref <- read.csv("refMaster.csv", stringsAsFactors = FALSE)
    ngenes <- length(octo.data@Dimnames[[1]])
      # Remove parentheses from names
    ref <- lapply(ref, gsub, pattern='\\(', replacement=' ')
    ref <- lapply(ref, gsub, pattern='\\)', replacement=' ')
    ref <- lapply(ref, gsub, pattern='_', replacement='-')
    ref$id = substr(ref$id, 1, 10)
      # Add on real gene names; can take some time but only has to be run once if you save
    ref2 <- data.frame(ref)
    for (g in 1:ngenes){
      gene <- octo.data@Dimnames[[1]][g]
      unlistgene <- unlist(strsplit(gene, "-"))
      geneList <- list()
      for (i in unlistgene){
        beginning <- substr(i, 0, 6)
        if(beginning == "Ocbimv"){
          ind <- grep(i, ref2$ncbi)
          idlist <- list(droplevels(factor(ref2$id[ind])))
          geneList <- c(geneList, idlist)
          octo.data@Dimnames[[1]][g] <- (paste(gene, (paste(unlist(geneList), collapse='-')),sep='-')[1])
        }
      }
    }
    
    # Save here
    saveRDS(octo.data, file = "octoData_shortNames2.rds")
  
all <- CreateSeuratObject(counts = all, project = "OctoSeq[f]", min.cells = 3, min.features = 200)
all

#all[["percent.mt"]] <- PercentageFeatureSet(all, pattern = "^mitochondria-") # Seurat uses this function to extract information re: mitochondrial genes

mito.genes <- grep(pattern = "^mitochondria-", x = rpwnames(x = all), value = TRUE)
percent.mito <- Matrix::colSums(all) / Matrix::colSums(all)
all[["percent.mt"]] <- PercentageFeatureSet(all, pattern = "^mitochondria-")

VlnPlot(all, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3) # visualize the relationship between three variables: nFeature (genes) nCount (UMI counts) and percent.mt (mitochondrial genes)

plot1 <- FeatureScatter(all, feature1 = "nCount_RNA", feature2 = "percent.mt") # visualize the relationship between UMI counts and mitochondrial genes (percent)
plot2 <- FeatureScatter(all, feature1 = "nCount_RNA", feature2 = "nFeature_RNA") # visualize the relationship between genes (ID as > 1 UMI count) and mitochondrial genes (percent)
plot1 + plot2

all <- subset(all, subset = nFeature_RNA > 200 & nFeature_RNA < 2500 & percent.mt < 5) # set parameters to include cells with the following critera: > 200, < 2500, less than 5% mitochondrial genes, since a higher number of mitochondrial genes is indicative of stress 

## Begin normalizing the data: Apply global scaling after removing unwanted cells from the dataset

all <- NormalizeData(all) # applies a Log Normalize by scale factor of 10,000 as default

## ID highly variable features (feature selection) 
# To calculate a subset of features that exhibit high cell-to-cell variation in the dataset (i.e. genes that are highly expressed in some cells and lowly expressed in others), the following function returns 2,000 features per data set, which will be used in downstream analyses like PCA
all <- FindVariableFeatures(all, selection.method = "vst", nfeatures = 2000)
top10 <- head(VariableFeatures(all), 10) # ID 10 most highly variable genes
plot1 <- VariableFeaturePlot(all)
plot2 <- LabelPoints(plot = plot1, points = top10, repel = TRUE)
plot1 + plot2

## Scale the data: this is a standard pre-processing step required for dimensional reduction techniques
# Applies a linear transformation: 1) shifts the expression of each gene so that the mean expression across cells is 0, 2) scales the expression of each gene so that the variance across cells is 1, allowing for downstream analyses to utilize equal weight of each gene so that highly-expressed genes do not dominate; 3) results will be stored in all[["RNA]]@scale.data
all.genes <- rownames(all)
all <- ScaleData(all, vars.to.regress = "nCount_RNA", "percent.mt") # regress out UMI counts and percent.mt which is helpful when integrating v2 and v3 chemistry; alt: all <- ScaleData(all, features = all.genes)
  }
}
```

## Integrate data sets after normalization before continuing with PCA
```{r}
if(x=1){
  allOSnorm <- merge(x = all1.norm, y = c(all2.norm, all3.norm), add.cellids = c("run1", "run2", "run3"), project = "", merge.data = TRUE)
  GetAssayData(allOSnorm) [1:10, 1:15]
  } else {
    allOSnorm <- merge(x = all4.norm, y = c(all5.norm, all6.norm), add.cellids = c("HSrun1", "HSrun2", "HSrun3"), project = "", merge.data = TRUE)
    GetAssayData(allOSnorm) [1:10, 1:15]
  } 
```

## Examine and visualize PCA results in a few different ways, comment out those that you don't need to visualize
```{r}
print(allOSnorm[["pca"]], dims = 1:5, nfeatures = 5)

VizDimLoadings(allOSnorm, dims = 1:2, reduction = "pca")

allOSnorm <- JackStraw(allOSnorm, num.replicate = 100) #JackStrawPlot is not able to compute more than 20 pcs
allOSnorm <- ScoreJackStraw(allOSnorm, dims = 1:20)
JackStrawPlot(allOSnorm, dims = 1:20)

ElbowPlot(allOSnorm)

DimPlot(allOSnorm, reduction = "pca", pt.size = 2)
DimPlot(allOSnorm, reduction = "pca", dims = c(19,20), pt.size = 2)

DimHeatmap(allOSnorm, dims = 1, cells = 500, balanced = TRUE)
DimHeatmap(allOSnorm, dims = 1:10, cells = 500, balanced = TRUE)
```

## Clustering steps
```{r}
allOSnorm <- FindNeighbors(allOSnorm, dims = 1:20)
allOSnorm <- FindClsuters(allOsnorm, reduction.type = "pca", dims = 1:20, resolution = 1)
head(Idents(allOSnorm), 5)
allOSnorm <- RunUMAP(allOSnorm, dims = 1:20)
DimPlot(allOSnorm, reduction = "umap", pt.size = 1)
```

## Building a dendogram to reflect hierarchical clustering
```{r}
allOSnorm.tree <- BuildClusterTree(allOSnorm, reorder = TRUE, reorder.numeric = TRUE, slot = "scale.data", verbose = TRUE, dims = 1:20)
pdf("clusterTree.pdf", height = 4.5, width = 7)
PlotclusterTree(allOSnorm.tree)
dev.off()

allOSnorm.tree <- RunUMAP(allOSnorm.tree, dims = 1:20)
pdf("hierarchicalTree.pdf", height = 7, width = 10)
DimPlot(allOSnorm.tree, reduction = "umap", label = TRUE, pt.size = 1)
dev.off()
```

## Finding markers
```{r}
if (t = 1){
  cluster1.markersROC <- FindMarkers(allOsnorm.tree, ident.1 = 1, logfc.threshold = 0.25, test.use = "roc", only.pos = TRUE)
  head(cluster1.markersROC, n = 2)
  VlnPlot(allOSnorm.tree, features = c("", "", ""))
  
  cluster2.markersROC <- FindMarkers(allOsnorm.tree, ident.1 = 2, logfc.threshold = 0.25, test.use = "roc", only.pos = TRUE)
  head(cluster2.markersROC, n = 5)
  VlnPlot(allOSnorm.tree, features = c("", "", ""))
  
  octo.markers <- FindAllMarkers(allOSnorm.tree, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)
  
  cluster30_33.markers <- FindMarkers(allOSnorm.tree, ident.1 = c(30, 31, 32, 33), ident.2 = c(1, 2, 3, 4, 5, 6...)) # placed elipses here instead of writing out entire 1-29, but have not tested if elipses is sufficient to run command
  
  top2 <- octo.markers %>% group_by(cluster) %>% top_n(n = 2, wt = avg_logFC)
  write.table(top2, ".csv", sep = ",", quote = FALSE)
  saveRDS (octo.markers, file = ".rds")
  
}else{
   cluster1.markersROC <- FindMarkers(allOsnorm, ident.1 = 1, logfc.threshold = 0.25, test.use = "roc", only.pos = TRUE)
  head(cluster1.markersROC, n = 2)
  VlnPlot(allOSnorm.tree, features = c("", "", ""))
  
  cluster2.markersROC <- FindMarkers(allOsnorm, ident.1 = 2, logfc.threshold = 0.25, test.use = "roc", only.pos = TRUE)
  head(cluster2.markersROC, n = 5)
  VlnPlot(allOSnorm.tree, features = c("", "", ""))
  
  octo.markers <- FindAllMarkers(allOSnorm, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)
  
  cluster30_33.markers <- FindMarkers(allOSnorm, ident.1 = c(30, 31, 32, 33), ident.2 = c(1, 2, 3, 4, 5, 6...)) # placed elipses here instead of writing out entire 1-29, but have not tested if elipses is sufficient to run command
  
  top2 <- octo.markers %>% group_by(cluster) %>% top_n(n = 2, wt = avg_logFC)
  write.table(top2, ".csv", sep = ",", quote = FALSE)
  saveRDS (octo.markers, file = ".rds")
}
```

## Unchecked code for rest of Gabby's Rmd
```{r}

#NeuroGenes from Judit
neuroGenes <- read.table("NeuroGenes.csv",header = TRUE, sep = ",")
#DevoGenes from Judit
DevoGenes <- read.table("DevoGenes.csv", header=TRUE, sep = ",")



#Add extra column (change based on which csv you are using)
DevoGenes$fullName=""



#This loop searches for the full names of the DevoGenes within the octo.norm object
#and then pastes them into the new "fullname" column
for (row in 1:nrow(DevoGenes)){
 p = DevoGenes[row,"ID"]
 #print(p)
 newName = grep(pattern = p, x = rownames(x = octo.norm), value = TRUE)
 if (identical(newName,character(0))){
   DevoGenes$fullName[row] = "none"
 }
 else if (length(newName) != 1){
   l = length(newName)
   DevoGenes$fullName[row] = newName[l]
 }
 else{
   DevoGenes$fullName[row] = newName
 }
}



#This removes any of the Devo/Neuro genes that were not found in the octo.norm object
#These are not found because hisat did not "pick up" all of the ocbimv names
#For those, I found them in IGV and manually created the figures outside of the loop
DevoGenesN = data.frame()
for (row in 1:nrow(DevoGenesN)){
 if (DevoGenes$fullName[row] != "none"){
   DevoGenesN <- rbind(DevoGenesN, DevoGenes[row,])
 }
}



#Remove any spaces in the names
DevoGenesN$Gene <- lapply(DevoGenesN$Gene, gsub, pattern=' ', replacement='-')
#Remove any / in the names
#neuroGenesN <- lapply(neuroGenesN, gsub, pattern='/', replacement='-')



#=========================================================



setwd("C:/Users/User/Documents/MillerLab/cellranger")



#This loop runs each row in DevoGenesN and prints out a png file for each type of graph
#Make sure to set the working directory to a place that you want all these figures to be saved!
for (row in 1:nrow(DevoGenesN)){



 name = DevoGenesN$fullName[row]
 name2 = DevoGenesN$fullName[row]
 name2 <- lapply(name2, gsub, pattern='/', replacement='-')
 name2 <- lapply(name2, gsub, pattern='\\?', replacement='-')
 name2 <- lapply(name2, gsub, pattern=' ', replacement='-')
 name2 <- lapply(name2, gsub, pattern='\\"', replacement='-')
 name2 <- substr(name2,1,60)
 gene = DevoGenesN$Gene[row]


 vlnplotName = paste(gene, name2, "vlnplot.png", sep = "_")
 png(vlnplotName, width = 900, height = 700)
 vln <- VlnPlot(octo.normTREE, features = name)
 print(vln)
 dev.off()



 dotplotName = paste(gene, name2,'dotplot.png', sep = '_')
 png(dotplotName, width = 900, height = 700)
 dp <- DotPlot(octo.normTREE, features = name)
 print(dp)
 dev.off()


 featureplotName = paste(gene, name2,'featureplot.png', sep = '_')
 png(featureplotName, width = 900, height = 700)
 fp <- FeaturePlot(octo.normTREE, features = name, sort.cell = TRUE, pt.size = 1.5)
 print(fp)
 dev.off()
}

```



